syntax = "proto3";
package hexzpb;

import "google/protobuf/timestamp.proto";
option go_package = "github.com/dnswlt/hexz/hexzpb";

message Board {
    enum GameState {
        INITIAL = 0;
        RUNNING = 1;
        FINISHED = 2;
    }
    int32 turn = 1;
    int32 move = 2;
    int32 last_revealed = 3;
    repeated Field flat_fields = 4;
    repeated int32 score = 5;
    repeated ResourceInfo resources = 6;
    GameState state = 7;
}

message Field {
    enum CellType {
        NORMAL = 0;
        DEAD = 1;
        GRASS = 2;
        ROCK = 3;
        FIRE = 4;
        FLAG = 5;
        PEST = 6;
        DEATH = 7;
    }
    CellType type = 1;
    int32 owner = 2;
    bool hidden = 3;
    int32 value = 4;
    int32 blocked = 5;
    int32 lifetime = 6;
    repeated int32 next_val = 7;
}

message ResourceInfo {
    // Has exactly as many elements as there are cell types.
    repeated int32 num_pieces = 1;
}

message Player {
    string id = 1;
    string name = 2;
}

// GameInfo is summary information about an ongoing game, used to 
// display a list of games to the user.
message GameInfo {
    string id = 1;
    string host = 2; // The player hosting the game.
    google.protobuf.Timestamp started = 3;
    string type = 4; // Expected to match a hexz.GameType value.
    bool cpu_player = 5; // True if this is a single player game against a CPU player.
}

// This message contains all data to restore a game state.
// It can be used to save and load games in a memory store.
message GameState {
    GameInfo game_info = 1;
    int64 seqnum = 2;
    google.protobuf.Timestamp modified = 4;
    // Players in this game, in the order they joined.
    repeated Player players = 5;
    GameEngineState engine_state = 6;
}

// This message contains all data to restore a game engine state.
// Every GameEngine implementation implements the .Encode() method
// to encode its state into this message.
message GameEngineState {
    oneof state {
        // All game engine types should have one field in this oneof.
        GameEngineFlagzState flagz = 1;
        GameEngineClassicState classic = 2;
        GameEngineFreeformState freeform = 3;
    }
}

// The encoded state of a GameEngineFlagz. Used for saving and loading games.
message GameEngineFlagzState {
    Board board = 1;
    int32 free_cells = 2;
    // Always exactly two elements, one per player.
    repeated int32 normal_moves = 3;
    // History of moves made so far.
    repeated GameEngineMove moves = 4;
}

// The encoded state of a GameEngineClassic. Used for saving and loading games.
message GameEngineClassicState {
    Board board = 1;
}

// The encoded state of a GameEngineFreeform. Used for saving and loading games.
message GameEngineFreeformState {
    Board board = 1;
}

message GameEngineMove {
    int32 player_num = 1;
	int32 move = 2;
	int32 row = 3;
	int32 col = 4;
	Field.CellType cell_type = 5;
}

// MCTSExample encodes all data that is necessary to generate a training example
// for the NeuraMCTS model.
// Normally, examples would be saved as HDF5 files, but to be facilitate the
// generation of examples in our highly optimized Go implementation, we use
// this message format instead. Python code can transform this into HDF5 files.
message MCTSExample {
    string game_id = 1;
    // The board, at any step in a fully played game.
    Board board = 2;
    // The "value", i.e. the final result of the game. Always has two elements.
    repeated int32 result = 3;
    // The learnt "policy", i.e. the MCTS visit counts and win rates for each move.
    message MoveStats {
        GameEngineMove move = 1;
        int32 visits = 2;
        float win_rate = 3;
    }
    repeated MoveStats move_stats = 4;
}

message ModelKey {
    string name = 1;
    int32 checkpoint = 2;
}

// Used by workers to upload examples to the training server.
message AddTrainingExamplesRequest {
    ModelKey model_key = 1;
    repeated TrainingExample examples = 2;
}

message AddTrainingExamplesResponse {
    enum Status {
        STATUS_UNSPECIFIED = 0;
        ACCEPTED = 1;
        REJECTED_TRAINING = 2;
        REJECTED_WRONG_MODEL = 3;
        REJECTED_OTHER = 4;
    }
    Status status = 1;
    // Tells the worker which model to use for subsequent requests.
    ModelKey latest_model = 2;
    // Populated if there was an error processing the request.
    string error_message = 3;
}

// TrainingExample is used to send training examples across the wire and store
// them on disk in the Python implementation.
message TrainingExample {
    // Timestamp at which this example was generated.
    int64 unix_micros = 1;
    // Time it took to generate this example (i.e., to generate the corresponding
    // neural MCTS move suggestion).
    int64 duration_micros = 5;

    // Training inputs.
    // Numpy array containing the (9, 11, 10) Board.
    // Serialized to bytes using np.save.
    bytes board = 2;

    // Training labels.
    // Numpy array containing the (2, 11, 10) move likelihoods.
    // Serialized to bytes using np.save.
    bytes move_probs = 3;
    // The outcome of the game, from the perspective of player 0.
    float result = 4;
}
